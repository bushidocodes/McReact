import TopLevelWrapper from "./TopLevelWrapper.js";
import McReactCompositeComponentWrapper from "./McReactCompositeComponentWrapper.js";
import McReactReconciler from "./McReactReconciler.js";
import { mixSpecIntoComponent, McReactInstanceMap } from "./utils.js";

function McReactComponent() {}

McReactComponent.prototype.setState = function(partialState) {
  const internalInstance = McReactInstanceMap.get(this);

  internalInstance._pendingPartialState = partialState;

  McReactReconciler.performUpdateIfNecessary(internalInstance);
};

const McReact = {
  /**
   * Creates the VDOM representation of an element on the McReact component tree
   *
   * @param {*} type - either a string of a known DOM type or a McReact class
   * @param {*} props - props that we want to pass to the element
   * @param {*} children - children of the element in the McReact component tree
   * @returns
   */
  createElement(type, props, children) {
    const element = {
      type,
      props: props || {}
    };

    if (children) {
      element.props.children = children;
    }

    return element;
  },

  /**
   * Defines a McReact Component Class
   *
   * @param {*} spec
   * @returns
   */
  createClass(spec) {
    // Create a generic constructor for a class whose prototype inherits from McReactComponent
    function Constructor(props) {
      // set props
      this.props = props;

      // setup initial state
      const initialState = this.getInitialState ? this.getInitialState() : null;
      this.state = initialState;
    }

    // chain prototype to McReactComponent
    Constructor.prototype = new McReactComponent();

    // Customize the generic constructor with the specification that the user passed into McReact.createClass
    mixSpecIntoComponent(Constructor, spec);
    return Constructor;
  },

  /**
   * Renders the component tree, either by mounting all nodes or updating the existing DOM nodes
   *
   * @param {*} element - VDOM representation of the root element generated by McReact.createElement
   * @param {*} container - Physical DOM container
   * @returns
   */
  render(element, container) {
    // Check for a root component in the container to know if this is the initial render or a rerender
    const prevComponent = getTopLevelComponentInContainer(container);
    if (prevComponent) {
      // TODO: We are just blindly using the existing root component. This means that we aren't able to know
      // when we need to unmount and then rerender the entire tree
      return updateRootComponent(prevComponent, element);
    } else {
      return renderNewRootComponent(element, container);
    }
  }
};

/**
 * Render the root element in the DOM container for the first time
 *
 * @param {*} element
 * @param {*} container
 * @returns
 */
function renderNewRootComponent(element, container) {
  // In our component tree, we always render a top level wrapper which we use to store the VDOM
  const wrapperElement = McReact.createElement(TopLevelWrapper, element);
  const componentInstance = new McReactCompositeComponentWrapper(
    wrapperElement
  );

  // Via the reconciler, mount the component in the container
  const markUp = McReactReconciler.mountComponent(componentInstance, container);

  // and then stash the virtual dom representation on the top level wrapper
  container.__mcreactComponentInstance = componentInstance._renderedComponent;

  return markUp;
}

/**
 * Retrieves the VDOM from the root element or undefined if not found
 *
 * @param {*} container
 * @returns
 */
function getTopLevelComponentInContainer(container) {
  return container.__mcreactComponentInstance;
}

/**
 * Update the props and children of the root component
 *
 * @param {*} prevComponent
 * @param {*} nextElement
 */
function updateRootComponent(prevComponent, nextElement) {
  McReactReconciler.receiveComponent(prevComponent, nextElement);
}

export default McReact;
