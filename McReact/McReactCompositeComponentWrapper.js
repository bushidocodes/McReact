import McReactReconciler from "./McReactReconciler.js";
import McReactDOMComponent from "./McReactDOMComponent.js";
import { McReactInstanceMap } from "./utils.js";

/**
 * Internally generated class ("Internal Instance") that wraps a single instance of a McReact component ("Public Instance").
 * It keeps track of the virtual DOM from this component down and manages the component lifecycle (mount, render, and lifecycle hooks)
 *
 * @export
 * @class McReactCompositeComponentWrapper
 */
export default class McReactCompositeComponentWrapper {
  /**
   *Creates an instance of McReactCompositeComponentWrapper.
   * @param {*} element - A "Public Instance" created with McReact.createClass
   * @memberof McReactCompositeComponentWrapper
   */
  constructor(element) {
    // this._currentElement is the element (class and props) generated by McReact.createElement
    this._currentElement = element;
  }

  /**
   * Mounts the "Pubic Instance" at the container provided, triggering both componentWillMount
   * and componentDidMount if found on the Public Instance.
   *
   * @param {*} container
   * @returns
   * @memberof McReactCompositeComponentWrapper
   */
  mountComponent(container) {
    // Grab the constructor of the McReact class stored at type
    const Component = this._currentElement.type;
    // And create a new instance with the props (which already includes props.children)
    const componentInstance = new Component(this._currentElement.props);

    // The two lines below seem pretty redundant?

    // Saves componentInstance at this._instance
    this._instance = componentInstance;
    // Saves the component instance to this.__mcreactInternalInstance
    McReactInstanceMap.set(componentInstance, this);

    // Call the componentWillMount lifecycle hook if it exists on the instance
    if (componentInstance.componentWillMount) {
      componentInstance.componentWillMount();
    }

    // Mount the component instance
    // TODO: Figure out what markup is here?
    const markup = this.performInitialMount(container);

    // Call the componentDidMount lifecycle hook if it exists on the component instance
    if (componentInstance.componentDidMount) {
      componentInstance.componentDidMount();
    }

    return markup;
  }

  /**
   * Renders, Instantiates, and mounts the Component in the container
   *
   * @param {*} container
   * @returns
   * @memberof McReactCompositeComponentWrapper
   */
  performInitialMount(container) {
    // Grab componentInstance from this._instance and call render, which returns the return value of a call to
    // McReact.createElement(). This is recursive, as this invokes McReact.createElement and McReact.createClass
    // down through the entire render tree, which builds the entire VDOM representation with this._instance as the
    // root node
    const renderedElement = this._instance.render();

    // Instantiate the immediate child, generating new CompositeComponentWrappers and trans
    const child = instantiateMcReactComponent(renderedElement);
    // and save it to this._renderedComponent
    this._renderedComponent = child;
    // Mount my child to my parent (the child's grandparent)?
    return McReactReconciler.mountComponent(child, container);
  }

  /**
   * Used to trigger an update when setState is called
   *
   * @memberof McReactCompositeComponentWrapper
   */
  performUpdateIfNecessary() {
    // we pass the same element as both previous and next in order to communicate that only state is getting updated
    this.updateComponent(this._currentElement, this._currentElement);
  }

  /**
   * Passed nextElement from McReactReconciler
   * Triggers updateComponent
   *
   * @param {*} nextElement
   * @memberof McReactCompositeComponentWrapper
   */
  receiveComponent(nextElement) {
    const prevElement = this._currentElement;
    // Make shallow compare here?
    this.updateComponent(prevElement, nextElement);
  }

  updateComponent(prevElement, nextElement) {
    const nextProps = nextElement.props;
    const inst = this._instance;

    // Checks to see if the element (class / props) has changed
    // This helps us know if we're only updating due to setState
    const willReceive = prevElement !== nextElement;

    // TODO: Implement componentWillUpdate here

    if (willReceive && inst.componentWillReceiveProps) {
      inst.componentWillReceiveProps(nextProps);
    }

    const nextState = Object.assign({}, inst.state, this._pendingPartialState);

    let shouldUpdate = true;
    // The user can affect if the component should update via this hook
    if (inst.shouldComponentUpdate) {
      shouldUpdate = inst.shouldComponentUpdate(nextProps, nextState);
    }

    if (shouldUpdate) {
      this._performComponentUpdate(nextElement, nextProps, nextState);
    } else {
      // If skipping update, still set props and state
      inst.props = nextProps;
    }
  }

  _performComponentUpdate(nextElement, nextProps, nextState) {
    this._currentElement = nextElement;
    const inst = this._instance;

    inst.props = nextProps;
    inst.state = nextState;

    this._updateRenderedComponent();
  }

  _updateRenderedComponent() {
    const prevComponentInstance = this._renderedComponent;
    const inst = this._instance;
    const nextRenderedElement = inst.render();

    McReactReconciler.receiveComponent(
      prevComponentInstance,
      nextRenderedElement
    );
  }
}

/**
 * Looks at the type of an element and determines if it is a DOM primitive or a McReact Component based on if
 * the type is a string or a function
 *
 * @param {Object} element
 * @returns
 */
function instantiateMcReactComponent(element) {
  if (typeof element.type === "string") {
    return new McReactDOMComponent(element);
  } else if (typeof element.type === "function") {
    return new McReactCompositeComponentWrapper(element);
  }
}
